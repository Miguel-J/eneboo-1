// This may look like C code, but it's really -*- C++ -*-
/*
 * Copyright (C) 2008 Emweb bvba, Kessel-Lo, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
#ifndef WIMAGE_H_
#define WIMAGE_H_

#include <Wt/WInteractWidget>

namespace Wt {

  namespace Impl {
    class MapWidget;
  }

  class WAbstractArea;

/*! \class WImage Wt/WImage Wt/WImage
 *  \brief A widget that displays an image.
 *
 * %WImage is an \link WWidget::setInline(bool) inline \endlink widget.
 *
 * The image may be specified either as a URL, or may be dynamically
 * generated by a WResource.
 *
 * You may listen to events by attaching event listeners to signals
 * such as %WInteractWidget::clicked or
 * WInteractWidget::keyPressed. Since mouse events pass the
 * coordinates through a WMouseEvent object, it is possible to react
 * to clicks in specific parts of the image. An alternative is to
 * define interactive areas on the image using addArea(), which in
 * addition allows to have customized tool tips for certain image
 * areas (using WAbstractArea::setToolTip()).
 */
class WT_API WImage : public WInteractWidget
{
public:
  /*! \brief Create an empty image widget.
   */
  WImage(WContainerWidget *parent = 0);

  /*! \brief Create an image widget with given image URL.
   */
  WImage(const std::string& imageRef, WContainerWidget *parent = 0);

  /*! \brief Create an image widget with given image URL and alternate text.
   */
  WImage(const std::string& imageRef, const WString& altText,
	 WContainerWidget *parent = 0);

  /*! \brief Create an image widget with given image resource and alternate
   *         text.
   *
   * Use this constructor if you want to present a dynamically generated
   * image.
   */
  WImage(WResource *resource, const WString& altText,
	 WContainerWidget *parent = 0);

  ~WImage();

  /*! \brief Set an alternate text.
   *
   * The alternate text should provide a fallback for browsers that do
   * not display an image. If no sensible fallback text can be
   * provided, an empty text is preferred over nonsense.
   *
   * This should not be confused with toolTip() text, which provides
   * additional information that is displayed when the mouse hovers
   * over the image.
   *
   * The default alternate text is an empty text ("").
   *
   * \sa alternateText()
   */
  void setAlternateText(const WString& text);

  /*! \brief Returns the alternate text.
   *
   * \sa setAlternateText()
   */
  const WString& alternateText() const { return altText_; }

  /*! \brief Set the image URL.
   *
   * This should not be used when the image is specified as a resource.
   *
   * \sa setResource()
   */
  void setImageRef(const std::string& url);

  /*! \brief Returns the image URL.
   *
   * When the image is specified as a resource, this returns the current
   * resource URL.
   */
  const std::string imageRef() const;

  /*! \brief Set the image resource.
   *
   * A resource specifies application-dependent content, which may be
   * used to generate an image on demand.
   *
   * This sets <i>resource</i> as the contents for the image, as an
   * alternative to setImageRef(). The resource may be cleared by
   * passing <i>resource</i> = 0.
   *
   * The image does not assume ownership of the resource.
   *
   * \sa setImageRef()
   */
  void setResource(WResource *resource);

  /*! \brief Returns the image resource.
   *
   * Returns 0 if no image resource was set.
   */
  WResource *resource() const { return resource_; }

  /*! \brief Add an interactive area.
   *
   * Adds the <i>area</i> which listens to events in a specific region
   * of the image. Areas are organized in an indexed list, to which
   * the given <i>area</i> is appended. When areas overlap, the area
   * with the lowest index receives the event.
   *
   * Ownership of the <i>area</i> is transferred to the image.
   *
   * \sa insertArea(int, WAbstractArea *)
   */
  void addArea(WAbstractArea *area);

  /*! \brief Insert an interactive area.
   *
   * Inserts the <i>area</i> which listens to events in the
   * coresponding area of the image. Areas are organized in a list,
   * and the <i>area</i> is inserted at index <i>index</i>. When areas
   * overlap, the area with the lowest index receives the event.
   *
   * Ownership of the <i>Area</i> is transferred to the image.
   *
   * \sa addArea(WAbstractArea *)
   */
  void insertArea(int index, WAbstractArea *area);

  /*! \brief Removes an interactive area.
   *
   * Removes the <i>area</i> from this widget, and also returns the
   * ownership.
   *
   * \sa addArea(WAbstractArea *)
   */
  void removeArea(WAbstractArea *area);

  /*! \brief Returns the interactive area at the given index.
   *
   * Returns 0 if <i>index</i> was invalid.
   *
   * \sa insertArea(int, WAbstractArea *)
   */
  WAbstractArea *area(int index) const;

  /*! \brief Returns the interactive areas set for this widget.
   *
   * \sa addArea()
   */
  const std::vector<WAbstractArea *> areas() const;

  /*! \brief Event emitted when the image was loaded.
   */
  EventSignal<void> loaded;

private:
  static const int BIT_ALT_TEXT_CHANGED = 0;
  static const int BIT_IMAGE_REF_CHANGED = 1;
  static const int BIT_MAP_CREATED = 2;

  WString                    altText_;
  std::string                imageRef_;
  WResource                 *resource_;
  Impl::MapWidget           *map_;
  std::bitset<3>             flags_;

  void resourceChanged();

protected:
  virtual void  updateDom(DomElement& element, bool all);
  virtual DomElementType domElementType() const;

  friend class WLabel;

  static std::vector<WAbstractArea *> noAreas_;
};

}

#endif // WIMAGE_H_
