// This may look like C code, but it's really -*- C++ -*-
/*
 * Copyright (C) 2008 Emweb bvba, Kessel-Lo, Belgium.
 *
 * See the LICENSE file for terms of use.
 */
#ifndef WAPPLICATION_
#define WAPPLICATION_

#include <vector>
#include <string>
#include <set>

#include <Wt/WObject>
#include <Wt/WCssStyleSheet>
#include <Wt/WEvent>
#include <Wt/WMessageResourceBundle>
#include <Wt/WSignal>
#include <Wt/WString>

/*! \file WApplication
 */

namespace Wt {

class WApplication;
class WContainerWidget;
class WEnvironment;
class WEvent;
class WLoadingIndicator;
class WLogEntry;
class WResource;
class WServerPushResource;
class WText;

namespace Ext {
  class Dialog;
  class MessageBox;
}

class WebSession;
class UpdateLockImpl;

#ifndef JAVA
/*! \brief Typedef for a function that creates WApplication objects.
 *
 * \sa WRun()
 *
 * \relates WApplication
 */
typedef WApplication* (*ApplicationCreator)(const WEnvironment& env);
#endif // !JAVA

/*! \class WApplication Wt/WApplication Wt/WApplication
 *  \brief A class that represents an instance of a %Wt Application,
 *         corresponding to a single session.
 *
 * For every new session, an instance of WApplication must be
 * created, before creating widgets. For this purpose, the user passes
 * a function that creates applications to WRun(). A general
 * structure for starting a %Wt Application could be:
 *
 * \code
 *   WApplication *createApplication(const WEnvironment WEnvironment& env) {
 *     //
 *     // Optionally, check the environment and redirect to an error page.
 *     //
 *     bool valid = ...;
 *    
 *     if (!valid) {
 *       WApplication *app = new WApplication(env);
 *       app->redirect("error.html");
 *       app->quit();
 *       return app;
 *     }
 *
 *     WApplication *app = new WApplication(env);
 *
 *     //
 *     // Add widgets to app->root() and return the application object.
 *     //
 *     return app;
 *   }
 * \endcode
 *
 * Throughout the application, the instance is available through
 * WApplication::instance() (or through #wApp). The application may be
 * quited either by calling quit(), or because of a timeout (when the
 * user has closed the window, or crashed its computer or was eaten by
 * a virus). In either case, the application object is deleted,
 * allowing for cleanup of the entire widget tree, and any other
 * resources.
 *
 * The %WApplication object provides access to:
 * <ul>
 *   <li>WEnvironment information through environment(), which gives
 *     details about the user and start-up
 *     arguments.</li>
 *   <li>inline and external style sheets using styleSheet() and
 *     useStyleSheet() respectively.</li>
 *   <li>the top-level widget, which is the root of the widget hierarchy,
 *     with root().</li>
 *   <li>localization information and message resources bundles, with
 *     setLocale(), locale() and messageResourceBundle().
 *   <li>the maximum configured request size (maximumRequestSize()) and
 *     a signal WApplication::requestTooLarge to react to too large
 *     requests.</li>
 *   <li>defining cookies using setCookie(). These cookies may provide
 *     context across sessions, and may be inspected using
 *     WEnvironment::getCookie() in a future session.</li>
 *   <li>support for internal application paths that enable browser
 *     history (back and forward buttons), and bookmarks, using the
 *     setInternalPath() and related methods.</li>
 *   <li>support for server-initiated updates with enableUpdates(),
 *     triggerUpdate() and getUpdateLock().</li>
 * </ul>
 */
class WT_API WApplication : public WObject
{
public:
  /*! \brief Enumeration that indicates the Ajax communication method.
   *
   * \sa setAjaxMethod()
   */
  enum AjaxMethod {
    XMLHttpRequest,  //!< Use the XMLHttpRequest object (real AJAX)
    DynamicScriptTag //!< Use dynamic script tags (for cross-domain AJAX)
  };

#ifndef JAVA
  /*! \brief Typedef for a function that creates WApplication objects.
   *
   * \sa WRun()
   */
  typedef Wt::ApplicationCreator ApplicationCreator;
#endif

  /*! \brief Construct a WApplication
   */
  WApplication(const WEnvironment& environment);

  /*! \brief Destructor.
   *
   * The destructor deletes the root() container, and as a consequence
   * the entire widget tree.
   */
  ~WApplication();

  /*! \brief Returns the current application instance.
   *
   * This is the same as the global variable #wApp. In a
   * multi-threaded server, it returns the thread-specific application
   * instance (using thread-specific storage).
   */
  static WApplication *instance();

  /*! \brief Returns the application environment.
   *
   * This is the environment that was used when constructing the
   * application. The environment contains all settings that constrain
   * the application from outside.
   */
  const WEnvironment& environment() const;

  /*! \brief Returns the root container.
   *
   * This is the top-level container for displaying widgets in the
   * application. The user interface of your application is
   * represented by the content of this container.
   *
   * \note In a \link WServer::WidgetSet WidgetSet\endlink mode, there
   * is no root() container, and 0 is returned
   *
   * \sa bindWidget()
   */
  WContainerWidget *root() const { return widgetRoot_; }

  /*! \brief Returns a reference to the inline style sheet.
   *
   * Widgets may allow configuration of their look and feel through
   * style classes. These may be defined in this inline stylesheet, or
   * in external style sheets.
   *
   * \sa useStyleSheet()
   */
  WCssStyleSheet& styleSheet() { return styleSheet_; }

  /*! \brief Adds an external style sheet.
   *
   * Widgets may allow configuration of their look and feel through
   * style classes. These may be defined in an inline stylesheet,
   * or in external style sheets.
   *
   * The <i>uri</i> indicates a relative or absolute URL to the
   * stylesheet.
   *
   * \sa styleSheet(), useStyleSheet(const std::string&, const std::string&)
   */
  void useStyleSheet(const std::string& uri);

  /*! \brief Adds an external style sheet, conditional for IE
   *
   * <i>condition</i> is a string that is used to apply the stylesheet
   * to specific versions of IE. Only a limited subset of the IE
   * conditional comments syntax is supported. Examples are:
   * - "IE gte 6": only for IE version 6 or later. 
   * - "!IE gte 6": only for IE versions prior to IE6.
   * - "IE lte 7": only for IE versions prior to IE7.
   *
   * The <i>uri</i> indicates a relative or absolute URL to the
   * stylesheet.
   *
   * \sa useStyleSheet(const std::string&)
   */
  void useStyleSheet(const std::string& uri, const std::string& condition);

 /*! \brief Set the title.
   *
   * Set the title that appears as the browser window title.
   *
   * The default title is "".
   *
   * \sa title()
   */
  void setTitle(const WString& text);

  /*! \brief Returns the title.
   *
   * \sa setTitle(const WString&)
   */
  const WString& title() const { return title_; }

  /*! \brief Returns the class that provides localized strings.
   *
   * The default value is a WMessageResourceBundle, which uses XML
   * files to resolve localized strings, but you can use a custom one
   * using setLocalizedStrings().
   *
   * \sa WString::tr(const char *key), messageResourceBundle()
   */
  WLocalizedStrings *localizedStrings() { return localizedStrings_; }

  /*! \brief Set the string translator.
   *
   * The string translator resolves localized strings in the current
   * locale. The previous string translator is deleted, and ownership is
   * transferred to the application.
   *
   * \sa stringTranslator(), WString::tr(const char *key)
   */
  void setLocalizedStrings(WLocalizedStrings *translator);

  /*! \brief Returns the message resource bundle.
   *
   * The message resource bundle defines the list of external XML
   * files that are used to lookup localized strings.
   *
   * The default stringTranslator() is a WMessageResourceBundle, and
   * this method returns the stringTranslator upcasted as a message
   * resource bundle.
   *
   * \sa WString::tr(const char *key)
   */
  WMessageResourceBundle& messageResourceBundle() const;

  /*! \brief Changes the locale.
   *
   * By passing a <i>locale</i> that is an empty string, the default
   * locale is chosen. The locale is used by the string translator to
   * resolve internationalized strings.
   *
   * When the locale gets changed, refresh() is called, which will
   * resolve the strings in the new locale.
   *
   * The default locale is copied from the environment
   * (WEnvironment::locale()), and is the locale that was configured
   * by the user in his browser preferences.
   *
   * \sa stringTranslator(), WString::tr()
   */
  void setLocale(const std::string& locale);

  /*! \brief Returns the currently used locale.
   *
   * \sa setLocale(const std::string&)
   */
  std::string locale() const { return locale_; }

  /*! \brief Refresh the application.
   *
   * Causes the application to refresh its data, including messages
   * from message-resource bundles. This done by propagating
   * WWidget::refresh() through the widget hierarchy.
   *
   * This method is also called in response to the user hitting the
   * refresh (or reload) button.
   *
   * \sa WWidget::refresh()
   */
  virtual void refresh();

  /*! \brief Bind a top-level widget for a WidgetSet deployment.
   *
   * This method binds a widget to an existing element on the page.
   * The element type should correspond with the widget type (e.g. it
   * should be a &lt;div&gt; for a WContainerWidget, or a
   * &lt;table&gt; for a WTable).
   *
   * \sa root(), \link WServer::WidgetSet WidgetSet mode\endlink.
   */
  void bindWidget(WWidget *widget, const std::string& domId);

  /*! \brief Returns the application name (<b>deprecated</b>).
   *
   * \deprecated Use the internal path to read the last file from the
   *             internal path.
   *
   * This name is the last file of the URL (including the initial
   * internal path) that was used to access the application.
   *
   * For example, for an application deployed at <tt>"/stuff/app.wt"</tt>,
   * When accessing the application using:
   * \code
   * http://www.mydomain.com/stuff/app.wt
   * \endcode
   * this method would return <tt>"app.wt"</tt>, but when accessing the
   * application using:
   * \code
   * http://www.mydomain.com/stuff/app.wt/file
   * \endcode
   * this method would return <tt>"file"</tt>.
   *
   * \sa url(), bookmarkUrl()
   */
  std::string applicationName() const;

  /*! \brief Returns a URL for the current session
   *
   * Returns the (relative) URL for this application session
   * (including the session ID if necessary). The URL includes the
   * full application path, and is expanded by the browser into a full
   * URL.
   *
   * For example, for an application deployed at
   * \code
   * http://www.mydomain.com/stuff/app.wt
   * \endcode
   * this method would return <tt>"/stuff/app.wt?wtd=AbCdEf"</tt>,
   * when using URL rewriting for session-tracking or
   * <tt>"/stuff/app.wt?a=a"</tt> when using cookies for
   * session-tracking (see also \ref config_session for configuring
   * the session-tracking method). As in each case, a query is
   * appended at the end of the URL, additional query parameters can
   * be appended in the form of <tt>"&param1=value&param2=value"</tt>.
   *
   * To obtain a URL that is suitable for bookmarking the current
   * application state, to be used across sessions, use bookmarkUrl()
   * instead.
   *
   * \sa redirect(), WEnvironment::hostName(), WEnvironment::urlScheme()
   * \sa bookmarkUrl()
   */
  std::string url() const;

  /*! \brief Returns a bookmarkable URL, including the internal path.
   *
   * Is equivalent to <tt>bookmarkUrl(internalPath())</tt>, see
   * bookmarkUrl(const std::string&) const.
   *
   * To obtain a URL that is refers to the current session of the
   * application, use url() instead.
   *
   * \sa url(), bookmarkUrl(const std::string&) const
   */
  std::string bookmarkUrl() const;

  /*! \brief Returns a bookmarkable URL for a given internal path.
   *
   * Returns the (relative) URL for this application that includes the
   * internal path <i>internalPath</i>, usable across sessions. The
   * URL is relative and expanded into a full URL by the browser.
   *
   * For example, for an application with current URL:
   * \code
   * http://www.mydomain.com/stuff/app.wt#/project/internal/
   * \endcode
   * when called with <tt>"/project/external"</tt>, this method would
   * return:
   *  - <tt>"app.wt/project/external/"</tt> when JavaScript is available, or
   *    the agent is a web spider, or
   *  - <tt>"app.wt/project/external/?wtd=AbCdEf"</tt> when no JavaScript
   *    is available and URL rewriting is used for session-tracking (see
   *    also \ref config_session for configuring the session-tracking method).
   *
   * When the application is deployed at a folder (ending with '/'),
   * this style of URLs is not possible, and URLs are of the form:
   *  - <tt>"?_=/project/external/"</tt> when JavaScript is available, or
   *    the agent is a web spider, or
   *  - <tt>"?_=/project/external/&wtd=AbCdEf"</tt> when no JavaScript
   *    is available and URL rewriting is used for session-tracking.
   *
   * You can use bookmarkUrl() as the destination for a WAnchor, and
   * listen to a click event is attached to a slot that switches to
   * the internal path <i>internalPath</i> (see
   * WAnchor::setRefInternalPath()). In this way, an anchor can be
   * used to switch between internal paths within an application
   * regardless of the situation (browser with or without Ajax
   * support, or a web spider bot), but still generates suitable URLs
   * across sessions, which can be used for bookmarking, opening in a
   * new window/tab, or indexing.
   *
   * To obtain a URL that refers to the current session of the
   * application, use url() instead.
   *
   * \sa url(), bookmarkUrl()
   */
  std::string bookmarkUrl(const std::string& internalPath) const;

  /*! \brief Change the internal path.
   *
   * A %Wt application may manage multiple virtual paths. The virtual
   * path is appended to the application URL. Depending on the
   * situation, the path is directly appended to the application URL
   * or it is appended using a name anchor (#).
   *
   * For example, for an application deployed at:
   * \code
   * http://www.mydomain.com/stuff/app.wt
   * \endcode
   * for which an <i>internalPath</i> <tt>"/project/z3cbc/details/"</tt> is
   * set, the two forms for the application URL are:
   * <ul>
   * <li> in a browser with AJAX:
   * \code
   * http://www.mydomain.com/stuff/app.wt#/project/z3cbc/details/
   * \endcode
   * </li><li>
   * or in other situations (no JavaScript):
   * \code
   * http://www.mydomain.com/stuff/app.wt/project/z3cbc/details/
   * \endcode
   *    This has as major consequence that from the browser stand point,
   *    the application now serves many different URLs. As a consequence,
   *    relative URLs will break. Still, you can specify relative URLs
   *    within your application (in for example WAnchor::setRef() or
   *    WImage::setImageRef()) since %Wt will transform them
   *    to absolute URLs when needed. But, this in turn may break deployments
   *    behind reverse proxies when the context paths differ. For the same
   *    reason, you will need to use absolute URLs in any XHTML or CSS you
   *    write manually. <br>
   *    This type of URLs are only used when the your application is
   *    deployed at a location that does not end with
   *    a '/'. Otherwise, %Wt will generate URLS like:
   * \code
   * http://www.mydomain.com/stuff/?_=/project/z3cbc/details/
   * \endcode
   * </li></ul>
   *
   * When the internal path is changed, an entry is added to the
   * browser history. When the user navigates back and forward through
   * this history (using the browser back/forward buttons), an \link
   * WApplication::internalPathChanged internalPathChanged
   * signal\endlink is emitted. You should listen to this signal to
   * switch the application to the corresponding state. When
   * <i>emitChange</i> is true, this signal is also emitted by setting
   * the path.
   *
   * A url that includes the internal path may be obtained using
   * bookmarkUrl().
   *
   * The <i>internalPath</i> must start and end with a '/'.
   *
   * \sa bookmarkUrl(), internalPath(), internalPathChanged
   */
  void setInternalPath(const std::string& internalPath,
		       bool emitChange = false);

  /*! \brief Returns the current internal path.
   *
   * When the application is just created, this is equal to
   * WEnvironment::internalPath().
   *
   * \sa setInternalPath(), internalPathNextPart(), internalPathMatches()
   */
  std::string internalPath() const;

  /*! \brief Returns part of the current internal path.
   *
   * This is a convenience method which returns the next folder in the
   * internal path, after the given <i>path</i>.
   *
   * For example, when the current internal path is
   * <tt>"/project/z3cbc/details/"</tt>, this method returns
   * <tt>"details"</tt> when called with <tt>"/project/z3cbc/"</tt> as
   * <i>path</i> argument.
   *
   * The <i>path</i> must start and end with a '/', and
   * internalPathMatches() should evaluate to <i>true</i> for the
   * given <i>path</i>. If not, an empty string is returned and an
   * error message is logged.
   *
   * \sa internalPath(), internalPathChanged
   */
  std::string internalPathNextPart(const std::string& path) const;

  /*! \brief Checks if the internal path matches a given path.
   *
   * Returns whether the current internalPath() starts with
   * <i>path</i> (or is equal to <i>path</i>). This may be useful
   * before changing <i>path</i> using setInternalPath() if you do not
   * intend to remove sub paths when the current internal path already
   * matches <i>path</i>.
   *
   * The <i>path</i> must start and end with a '/'.
   *
   * \sa setInternalPath(), internalPath()
   */
  bool internalPathMatches(const std::string& path) const;

  /*! \brief %Signal which indicates that the user changes the internal path.
   *
   * This signal propagates changes to the internal path, which are
   * usually triggered by the user using the browser back/forward
   * buttons.
   *
   * When the path changes, this signal is emitted for every prefix
   * whose next path element has changed. The prefix is passed as the
   * argument, and may be used by listening widgets to quickly
   * determine if they need to respond to the path change. This also
   * allows widgets to be created corresponding to each path element,
   * and respond in their turn to further internal path changes.
   *
   * For example, when the path would change from
   * <tt>"/mail/inbox/unread/5"</tt> to
   * <tt>"/mail/addressbook/public/27"</tt>, this signal would be
   * emitted three times, in the following sequence:
   *
   * <table style="margin: 0px auto;">
   *   <tr>
   *     <td><b>prefix</b></td>
   *     <td><b>internalPath()</b></td>
   *     <td><b>\link internalPathNextPart() internalPathNextPart(prefix)\endlink
   *       </b></td>
   *   </tr>
   *   <tr>
   *     <td><tt>"/mail/"</tt></td>
   *     <td><tt>"/mail/addressbook"</tt></td>
   *     <td><tt>"addressbook"</tt></td>
   *   </tr>
   *   <tr>
   *     <td><tt>"/mail/addressbook/"</tt></td>
   *     <td><tt>"/mail/addressbook/public"</tt></td>
   *     <td><tt>"public"</tt></td>
   *   </tr>
   *   <tr>
   *     <td><tt>"/mail/addressbook/public/"</tt></td>
   *     <td><tt>"/mail/addressbook/public/27"</tt></td>
   *     <td><tt>"27"</tt></td>
   *   </tr>
   * </table>
   *
   * When the application starts with a non-empty internal path, a
   * patch switch is simulated from "/" to the initial path, after the
   * application has been created.
   * Therefore you have two options to deal with the initial internal path
   * on application start up:
   * - ignore the internal path when creating the application (perhaps even
   *   using \link setInternalPath() setInternalPath("/")\endlink) and
   *   respond to the initial change. This simplifies the initialization
   *   of your application, at the potential cost of creating widgets that
   *   were not necessary.
   * - use the value of internalPath() to setup the application directly in
   *   the state that corresponds to the internal path.
   *
   * \sa setInternalPath()
   */
  Signal<std::string> internalPathChanged;

  /*! \brief Redirects the application to another location.
   *
   * The client will be redirected to a new location. Use this in
   * conjunction with quit() if you want to the application to be
   * terminated as well.
   *
   * Calling redirect() does not imply quit() since it may be useful
   * to switch between a non-secure and secure (SSL) transport
   * connection.
   */
  void redirect(const std::string& url);

  /*! \brief Returns the unique identifier for the current session.
   *
   * The session id is a string that uniquely identifies the current session.
   * Note that the actual contents has no particular meaning and client
   * applications should in no way try to interpret its value.
   */
  std::string sessionId() const;

  WebSession *session() { return session_; }

  /*! \brief Enable server-initiated updates.
   *
   * By default, updates to the user interface are possible only at
   * startup, during any event (in a slot), or at regular time points
   * using WTimer. This is the normal %Wt event loop.
   *
   * In some cases, one may want to modify the user interface from a
   * second thread, outside the event loop, or from socket events
   * (using the WSocketNotifier). While this may be worked around by
   * the WTimer, in some cases, there are bandwidth and processing
   * overheads associated which may be unnecessary, and which create a
   * trade-off with time resolution of the updates.
   *
   * A call to this method starts a so-called "server push". Widgets
   * may then be modified, created or deleted outside of the event
   * loop (from another thread), and are subsequently propagated by
   * calling triggerUpdate().
   *
   * <i>This works only if JavaScript is available on the client, and
   * is not considered a production quality feature (there are some
   * unwanted side effects that have to do with typical browser
   * limitations, such as the maximum number of simultaneous open
   * connections to a single web server).</i>.
   *
   * \sa triggerUpdate()
   */
  void enableUpdates();

  /*! \brief Returns whether server-initiated updates are enabled.
   *
   * True if server-initiated updates were enabled by a previous call to
   * enableUpdates().
   */
  bool updatesEnabled() const;

  /*! \brief Propagate server-initiated updates.
   *
   * Propagate changes made to the user interface outside of the main
   * event loop. This is only possible after a call to
   * enableUpdates(), and must be done while holding the UpdateLock
   * (or from within a socket event, see WSocketNotifier).
   *
   * \sa enableUpdates(), getUpdateLock()
   */
  void triggerUpdate();

  /*! \brief A synchronisation lock for manipulating and updating the
   *         application and its widgets outside of the event loop.
   *
   * You need to get this lock only when you want to manipulate
   * widgets outside of the event loop. Inside the event loop, this
   * lock is already held by the library itself.
   *
   * \sa getUpdateLock();
   */
  class WT_API UpdateLock {
  public:
    /*! \brief Copy constructor.
     *
     * By copying the lock, the lock is transferred. The original
     * object becomes empty, and its destructor has no effect of
     * releasing the lock.
     */
    UpdateLock(const UpdateLock&);

    /*! \brief Releases and destroys the scope dependent lock
     */
    ~UpdateLock();

  private:
    UpdateLock(WApplication& app);

    mutable UpdateLockImpl *impl_;

    friend class WApplication;
  };

  /*! \brief Attach an auxiliary thread to this application.
   *
   * In a multi-threaded environment, WApplication::instance() uses
   * thread-local data to retrieve the application object that
   * corresponds to the session currently being handled by the
   * thread. This is set automatically by the library whenever an
   * event is delivered to the application, or when you use the
   * getUpdateLock() to modify the application from an auxiliary
   * thread outside the normal event loop.
   *
   * When you want to manipulate the widget tree inside the main event
   * loop, but from within an auxiliary thread, then you cannot use
   * the getUpdateLock() since this will create an immediate dead
   * lock. Instead, you may attach the auxiliary thread to the
   * application, by calling this method from the auxiliary thread,
   * and in this way you can modify the application from within that
   * thread without needing the update lock.
   */
  void attachThread();

  /*! \brief Grabs and returns the lock for manipulating widgets outside
   *         the event loop.
   *
   * You need to keep this lock in scope while manipulating widgets
   * outside of the event loop. In normal cases, inside the %Wt event loop,
   * you do not need to care about it.
   *
   * \sa enableUpdates(), triggerUpdate()
   */
  UpdateLock getUpdateLock();

  /*! \brief Executes some JavaScript code.
   *
   * This method may be used to call some custom JavaScript code as
   * part of an event response.
   *
   * This function does not wait until the JavaScript is run, but
   * returns immediately. The JavaScript will be run after the normal
   * event handling, unless <i>afterLoaded</i> is set to false.
   */
  void doJavaScript(const std::string& javascript, bool afterLoaded = true);

  void addAutoJavaScript(const std::string& javascript);

  void declareJavaScriptFunction(const std::string& name,
				 const std::string& function);

  /*! \brief Load a JavaScript library.
   *
   * Attempt to load a JavaScript library. When <i>symbol</i> is not
   * empty, the library is only inserted in the page if the given
   * symbol is not yet defined.
   *
   * Returns true when the library was not yet loaded for this
   * application.
   *
   * JavaScript libraries may be loaded at any point in time. They
   * will be loaded before evaluating the normal event handling code,
   * but after javaScript that has been executed using
   * doJavaScript(..., false).
   */
  bool require(const std::string& uri,
	       const std::string& symbol = std::string());

  /*! \brief Process UI events.
   *
   * You may call this method during a long operation to:
   * <ul>
   *   <li>Propagate widget changes to the client.</li>
   *   <li>Process UI events.</li>
   * </ul>
   *
   * This method starts a recursive event loop, blocking the current
   * thread, and resumes when all events have been processed.
   */
  void processEvents();

  /*! \brief Read a configuration property.
   *
   * Tries to read a configured value for the property
   * <i>name</i>. The method returns whether a value is defined for
   * the property, and sets it to <i>value</i>.
   */
  static bool readConfigurationProperty(const std::string& name,
					std::string& value);

  /*! \brief Set the Ajax communication method.
   *
   * You may change the communication method only from within the
   * application constructor.
   *
   * The default method depends on your application deployment
   * type.
   *
   * For \link WServer::Application plain\endlink applications, \link
   * WApplication::XMLHttpRequest XMLHttpRequest\endlink is used,
   * while for \link WServer::WidgetSet widget set\endlink
   * applications, \link WApplication::DynamicScriptTag
   * DynamicScriptTag\endlink is used. The latter is less efficient,
   * but has the benefit to allow serving the application from a
   * different server than the page that hosts the embedded widgets.
   */
  void setAjaxMethod(AjaxMethod method);

  /*! \brief Returns the Ajax communication method.
   *
   * \sa setAjaxMethod()
   */
  AjaxMethod ajaxMethod() const { return ajaxMethod_; }

  std::string javaScriptClass() { return javaScriptClass_; }

  WContainerWidget *domRoot() const { return domRoot_; }
  WContainerWidget *domRoot2() const { return domRoot2_; }
  std::string       encodeObject(WObject *object);
  WObject          *decodeObject(const std::string& objectId) const;

  std::string fixRelativeUrl(const std::string& url) const;
  static std::string resourcesUrl();

  /*! \brief Initialize the application, post-construction.
   *
   * This method is invoked by the %Wt library after construction of a
   * new application. You may reimplement this method to do additional
   * initialization that is not possible from the constructor
   * (e.g. which uses virtual methods).
   */
  virtual void initialize();

  /*! \brief Finalize the application, pre-destruction.
   *
   * This method is invoked by the %Wt library before destruction of a
   * new application. You may reimplement this method to do additional
   * finalization that is not possible from the destructor (e.g. which
   * uses virtual methods).
   */
  virtual void finalize();

  /*! \brief Change the threshold for two-phase rendering.
   *
   * This changes the threshold for the communication size (in bytes) to
   * render invisible changes in one go. If the bandwidth for
   * rendering the invisible changes exceed the threshold, they will
   * be fetched in a second communication, after the visible changes
   * have been rendered.
   *
   * The value is a trade-off: setting it smaller will always use
   * two-phase rendering, increasing the total render time. Setting it
   * too large will increase the latency to render the visible
   * changes, since first all changes need to be received in the
   * browser.
   *
   * The initial value is read from the configuration file, see \ref
   * config_general.
   */
  void setTwoPhaseRenderingThreshold(int size);

  /*! \brief Set a new cookie.
   *
   * The name must be a valid cookie name (of type 'token': no special
   * characters or separators, see RFC2616 page 16). The value may be
   * anything. Specify the maximum age (in seconds) after which the
   * client must discard the cookie. To delete a cookie, use a value of '0'.
   *
   * By default the cookie only applies to the current path on the
   * current domain. To set a proper value for domain, see also RFC2109.
   *
   * Use cookies to recognize the same user returning at some later
   * time to your server or application.
   *
   * \sa WEnvironment::supportsCookies()
   */
  void setCookie(const std::string& name, const std::string& value,
		 int maxAge, const std::string& domain = "",
		 const std::string& path = "");

  /*! \brief Returns the current maximum size of a request to the application.
   *
   * The maximum request size is configured in the configuration file,
   * see \ref config_general.
   *
   * \sa requestTooLarge
   */
  int maximumRequestSize() const;

  /*! \brief Add an entry to the application log.
   *
   * Starts a new log entry of the given <i>type</i> in the %Wt
   * application log file. This method returns a stream-like object to
   * which the message may be streamed.
   *
   * A typical usage would be:
   * \code
   *  wApp->log("notice") << "User " << userName << " logged in successfully.";
   * \endcode
   *
   * This would create a log entry that looks like:
   * \verbatim
[2008-Jul-13 14:01:17.817348] 16879 [/app.wt Z2gCmSxIGjLHD73L] [notice] "User bart logged in successfully." \endverbatim
   *
   * \sa \ref config_general
   */
  WLogEntry log(const std::string& type) const;

  /*! \brief Set the loading indicator.
   *
   * The loading indicator is shown to indicate that a response from the server
   * is pending or JavaScript is being evaluated.
   *
   * The default loading indicator is a WDefaultLoadingIndicator.
   *
   * When setting a new loading indicator, the previous one is
   * deleted.
   */
  void setLoadingIndicator(WLoadingIndicator *indicator);

  /*! \brief Returns the loading indicator.
   *
   * \sa setLoadingIndicator()
   */
  WLoadingIndicator *loadingIndicator() const { return loadingIndicator_; }

  std::string onePixelGifUrl();

  std::string docType() const;

  /*! \brief Checkpoints the current application state with a key/value pair
   *         (<b>deprecated</b>).
   *
   * \deprecated Use the new internal path system instead,
   *             see setInternalPath().
   *
   * Provided for backwards compatibility with existing code, this method
   * encodes the key/value pair within the new internal path system, as:
   * \code
   * .../key/value/...
   * \endcode
   *
   * Multiple key/value pairs can be combined in the URL in the order
   * that they are (first) set. When changing an "earlier"
   * (higher-level) key/value pair, "later" (lower-level) pairs are
   * pruned from the URL (Warning! this does not completely reflect
   * the old behaviour, since there keys were never pruned away, but
   * it is more in the spirit of the hierarchical internal path
   * nature).
   *
   * An application object (such as a widget) that uses this deprecated
   * system for internal application state works as follows:
   * <ul>
   *   <li>a <i>key</i> is chosen for each part of the application state;</li>
   *   <li>use setState() to indicate a new state;</li>
   *   <li>examine the current state using state();</li>
   *   <li>respond to state changes by listening to the
   *    \link WApplication::stateChanged stateChanged signal\endlink for
   *    state related to its key.</li>
   * </ul>
   *
   * \sa state(), stateChanged, bookmarkUrl()
   * \sa setInternalPath()
   */
  void setState(const std::string& key, const std::string& value);

  /*! \brief Returns the current application state value associated
   *         with a specific key (<b>deprecated</b>).
   *
   * \deprecated Use the new internal path system instead,
   *             see setInternalPath().
   *
   * \sa setState(), bookmarkUrl()
   * \sa internalPath(), internalPathNextPart()
   */
  std::string state(const std::string& key) const;

  /*! \brief Returns a bookmarkable URL that captures the application state
   *         (<b>deprecated</b>).
   *
   * \deprecated Use the new internal path system instead,
   *             see setInternalPath().
   *
   * Like bookmarkUrl(), this method returns the (relative) URL for
   * this application, excluding session ID, but including the encoded
   * state for bookmarking. This method however returns the URL when
   * the state <i>state</i> would be set for the indicated
   * <i>scope</i>. This is useful for generating URLs for anchors
   * which a click event which generates that state.
   *
   * \sa url(), bookmarkUrl(), setState()
   * \sa bookmarkUrl(const std::string&) const
   */
  std::string bookmarkUrl(const std::string& scope, const std::string& state);

  /*! \brief %Signal which indicates a change in application state
   *         (<b>deprecated</b>).
   *
   * \deprecated Use the new internal path system instead,
   *             see setInternalPath().
   *
   * An application object that wishes to react to state changes should
   * listen to this signal.
   *
   * \sa setState()
   */
  Signal<std::string, std::string> stateChanged;

public slots:
  /*! \brief Quit the application.
   *
   * The method returns immediately, and has as effect that the
   * application will be terminated after the current event is
   * completed.
   *
   * The current widget tree (including any modifications still
   * pending) is rendered, and the application is terminated.
   *
   * You might want to make sure no more events can be received from
   * the user, by not having anything clickable, for example by
   * displaying only text. A better approach may be to also redirect()
   * the user to another page.
   */
  void quit();

public:
  /*! \brief %Signal which indicates that too a large POST was received.
   *
   * The integer parameter is the request that was received in bytes.
   */
  Signal<int> requestTooLarge; 

protected:
  /*! \brief Notify an event to the application.
   *
   * This method is called by the event loop for propagating an event
   * to the application. It provides a single point of entry for
   * events to the application.
   *
   * You will rarely want to reimplement this method, unless you wish
   * to have a single point for exception handling. In that case, you
   * should call the baseclass implementation WApplication::notify(),
   * and surround it in your own try - catch block for those
   * exceptions you wish to handle.
   *
   * Any uncaught exception will terminate the application.
   */
  virtual void notify(const WEvent& e);

  /*! \brief Returns whether a widget is exposed in the interface.
   *
   * The default implementation simply returns true, unless a modal
   * dialog is active, in which case it returns true only for widgets
   * that are inside the dialog.
   *
   * You may want to reimplement this method if you wish to disallow
   * events from certain widgets even when they are inserted in the
   * widget hierachy.
   */
  virtual bool isExposed(WWidget *w) const;

  void exposeOnly(WWidget *w);

private:
  struct ScriptLibrary {
    ScriptLibrary(const std::string& uri, const std::string& symbol);

    std::string uri, symbol, beforeLoadJS;
    bool operator< (const ScriptLibrary& other) const;
    bool operator== (const ScriptLibrary& other) const;
  };

  struct State {
    State(const std::string& scope, const std::string& value);

    std::string scope;
    std::string value;
  };

  typedef std::vector<State> StateList;
  typedef std::map<std::string, EventSignalBase *> SignalMap;
  typedef std::map<std::string, WResource *> ResourceMap;
  typedef std::map<std::string, WObject *> ObjectMap;

  /*
   * Basic application stuff
   */
  WebSession            *session_;
  WString                title_;
  bool                   titleChanged_;
  WContainerWidget      *widgetRoot_;  // widgets in main DOM root
  WContainerWidget      *domRoot_;     // main DOM root
  WContainerWidget      *domRoot2_;    // other virtual root for WidgetSet mode
  WContainerWidget      *timerRoot_;   // timers in main DOM root
  WCssStyleSheet         styleSheet_;
  WLocalizedStrings     *localizedStrings_;
  std::string            locale_;
  std::string            newInternalPath_;
  bool                   internalPathChanged_;
  StateList              states_;
  bool                   useStates_;
  WServerPushResource   *serverPush_;
  bool			 shouldTriggerUpdate_;
  std::string            javaScriptClass_;
  AjaxMethod             ajaxMethod_;
  WContainerWidget      *dialogCover_;
  WContainerWidget      *dialogWindow_;
  bool                   quited_;
  std::string            onePixelGifUrl_;
  bool                   rshLoaded_;
  WWidget               *exposedOnly_;
  WLoadingIndicator     *loadingIndicator_;

  std::vector<ScriptLibrary> scriptLibraries_;
  int                        scriptLibrariesAdded_;

  std::vector<std::string> styleSheets_;
  int                      styleSheetsAdded_;

  SignalMap   exposedSignals_;   // signals that may be accessed
  ResourceMap exposedResources_; // resources that may be accessed
  ObjectMap   encodedObjects_;   // objects encoded for internal purposes
                                 // like 'virtual pointers' (see D&D)

  bool exposeSignals_;           // if we are currently exposing signals
                                 // (see WViewWidget)

  std::string afterLoadJavaScript_, beforeLoadJavaScript_,
    newBeforeLoadJavaScript_, autoJavaScript_;
  bool autoJavaScriptChanged_;

  EventSignal<WResponseEvent> javaScriptResponse_;
  EventSignal<void> showLoadingIndicator_, hideLoadingIndicator_;

  bool              isQuited() const { return quited_; }
  WContainerWidget *timerRoot() const { return timerRoot_; }
  WContainerWidget *dialogCover(bool create = true);
  WContainerWidget *dialogWindow(bool create = true);

  WEnvironment&     env();       // short-hand for session_->env()

  /*
   * Functions for exposed signals, resources, and objects
   */
  void              addExposedSignal(EventSignalBase* signal);
  void              removeExposedSignal(EventSignalBase* signal);
  EventSignalBase  *decodeExposedSignal(const std::string& signalName) const;
  EventSignalBase  *decodeExposedSignal(const std::string& objectId,
				       const std::string& name);
  const SignalMap&  exposedSignals() const;

  std::string       addExposedResource(WResource *resource);
  void              removeExposedResource(WResource *resource);
  WResource        *decodeExposedResource(const std::string& resourceName)
    const;

  /*
   * Methods for application state handling
   */
  bool              loadRsh();
  void              setInternalPathFromStates();
  void              setStatesFromInternalPath();
  void              changeInternalPath(const std::string& path);

  void handleJavaScriptResponse(WResponseEvent event);

  /*
   * Methods for accessing javaScript, which may have erase-on-read
   * semantics
   */
  std::string afterLoadJavaScript();
  std::string beforeLoadJavaScript();
  std::string newBeforeLoadJavaScript();

  /*
   * Methods for accessing exposeSignals_
   */
  void setExposeSignals(bool how) { exposeSignals_ = how; }
  bool exposeSignals() const { return exposeSignals_; }

  static bool pathMatches(const std::string& path, const std::string& query);

  friend class WebRenderer;
  friend class WebSession;
  friend class WebController;
  friend class EventSignalBase;
  friend class JavaScriptEvent;
  friend class UpdateLockImpl;
  friend class WWidget;
  friend class WTimer;
  friend class WResource;
  friend class WFileUpload;
  friend class WInteractWidget;
  friend class WServerPushResource;
  friend class WViewWidget;
  friend class WDialog;
  friend class Ext::Dialog;
  friend class Ext::MessageBox;
};

#ifdef WIN32
  #ifdef WTHTTP_STATIC
    #define WTCONNECTOR_API
  #else
    #ifdef wthttp_EXPORTS
      #define WTCONNECTOR_API __declspec(dllexport)
    #else
      #define WTCONNECTOR_API __declspec(dllimport)
    #endif
  #endif
#else
  #define WTCONNECTOR_API
#endif

#ifndef JAVA
#ifdef DOXYGEN_ONLY
/*! \brief Runs the %Wt application server.
 *
 * This function runs the application server, and should be called
 * only once (e.g. from within your main function).
 *
 * The <i>createApplication</i> argument is a function pointer to
 * create new application instances for each new user surfing to your application.
 *
 * When using the built-in httpd, the implementation listens for POSIX
 * termination signals (or console CTRL-C) event. You can use the
 * WServer class for more flexible control on starting and stopping
 * the server.
 *
 * \relates WServer
 * \sa WApplication
 */
extern int WRun(int argc, char** argv,
		ApplicationCreator createApplication = 0);
#else // DOXYGEN_ONLY
extern int WTCONNECTOR_API WRun(int argc, char** argv,
				ApplicationCreator createApplication = 0);

#endif // DOXYGEN_ONLY
#endif // JAVA

/*! \def wApp
 *  \brief Global constant for accessing the application instance.
 *
 * This is equivalent to WApplication::instance()
 *
 * \relates WApplication
 */
#define wApp Wt::WApplication::instance()

}

#endif // WAPPLICATION_
